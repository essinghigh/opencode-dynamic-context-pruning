Prunes tool outputs from context to manage conversation size and reduce noise.

## IMPORTANT: The Prunable List
A `<prunable-tools>` list is injected into user messages showing available tool outputs you can prune when there are tools available for pruning. Each line has the format `ID: tool, parameter` (e.g., `20: read, /path/to/file.ts`). You MUST only use numeric IDs that appear in this list to select which tools to prune.

**Note:** For `write` and `edit` tools, pruning removes the input content (the code being written/edited) while preserving the output confirmation. This is useful after completing a file modification when you no longer need the raw content in context.

## CRITICAL: When and How to Prune

You must use this tool in three specific scenarios. The rules for distillation (summarizing findings) differ for each. **You must provide a `metadata` object with a `reason` and optional `distillation`** to indicate which scenario applies.

### 1. Task Completion (Clean Up) — reason: `completion`
**When:** You have successfully completed a specific unit of work (e.g., fixed a bug, wrote a file, answered a question).
**Action:** Prune the tools used for that task.
**Distillation:** FORBIDDEN. Do not summarize completed work.

### 2. Removing Noise (Garbage Collection) — reason: `noise`
**When:** You have read files or run commands that turned out to be irrelevant, unhelpful, or outdated (meaning later tools have provided fresher, more valid information).
**Action:** Prune these specific tool outputs immediately.
**Distillation:** FORBIDDEN. Do not summarize noise.

### 3. Context Conservation (Research & Consolidation) — reason: `consolidation`
**When:** You have gathered useful information. Wait until you have several items or a few large outputs to prune, rather than doing tiny, frequent prunes. Aim for high-impact prunes that significantly reduce context size.
**Action:** Convert raw data into distilled knowledge. This allows you to discard large outputs (like full file reads) while keeping only the specific parts you need (like a single function signature or constant).
**Distillation:** MANDATORY. You MUST provide the distilled findings in the `metadata.distillation` parameter of the `prune` tool (as an object).
   - **Comprehensive Capture:** Distillation is not just a summary. It must be a high-fidelity representation of the technical details. If you read a file, the distillation should include function signatures, specific logic flows, constant values, and any constraints or edge cases discovered.
   - **Task-Relevant Verbosity:** Be as verbose as necessary to ensure that the "distilled" version is a complete substitute for the raw output for the task at hand. If you will need to reference a specific algorithm or interface later, include it in its entirety within the distillation.
    - **Consolidate:** When pruning multiple tools, your `distillation` object MUST contain a corresponding entry for EVERY ID being pruned. You must capture high-fidelity findings for each tool individually to ensure no signal is lost.
    - Structure: Map EVERY `ID` from the `ids` array to its specific distilled findings.
      Example: `{ "20": { ... }, "21": { ... } }`
   - Capture all relevant details (function names, logic, constraints) to ensure no signal is lost.
   - Prioritize information that is essential for the immediate next steps of your plan.
   - Once distilled into the `metadata` object, the raw tool output can be safely pruned.
   - **Know when distillation isn't enough:** If you'll need to edit a file, grep for exact strings, or reference precise syntax, keep the raw output. Distillation works for understanding; implementation often requires the original.
   - **Prefer keeping over re-fetching:** If uncertain whether you'll need the output again, keep it. The cost of retaining context is lower than the cost of redundant tool calls.

## Best Practices
- **Technical Fidelity:** Ensure that types, parameters, and return values are preserved if they are relevant to upcoming implementation steps.
- **Strategic Consolidation:** Don't prune single small tool outputs (like short bash commands) unless they are pure noise. Instead, wait until you have several items or large outputs to perform high-impact prunes. This balances the need for an agile context with the efficiency of larger batches.
- **Think ahead:** Before pruning, ask: "Will I need this output for an upcoming task?" If you researched a file you'll later edit, or gathered context for implementation, do NOT prune it.

## Examples

<example_noise>
Assistant: [Reads 'wrong_file.ts']
This file isn't relevant to the auth system. I'll remove it to clear the context.
[Uses prune with ids: ["5"], metadata: { "reason": "noise" }]
</example_noise>

<example_consolidation>
Assistant: [Reads service implementation, types, and config]
I'll preserve the full technical specification and implementation logic before pruning.
[Uses prune with ids: ["10", "11", "12"], metadata: {
  "reason": "consolidation",
  "distillation": {
    "10": {
      "file": "src/services/auth.ts",
      "signatures": [
        "async function validateToken(token: string): Promise<User | null>",
        "function hashPassword(password: string): string"
      ],
      "logic": "The validateToken function first checks the local cache before calling the external OIDC provider. It uses a 5-minute TTL for cached tokens.",
      "dependencies": ["import { cache } from '../utils/cache'", "import { oidc } from '../config'"],
      "constraints": "Tokens must be at least 128 chars long. hashPassword uses bcrypt with 12 rounds."
    },
    "11": {
      "file": "src/types/user.ts",
      "interface": "interface User { id: string; email: string; permissions: ('read' | 'write' | 'admin')[]; status: 'active' | 'suspended'; }",
      "context": "The permissions array is strictly typed and used by the RBAC middleware."
    },
    "12": {
      "file": "config/default.json",
      "values": { "PORT": 3000, "RETRY_STRATEGY": "exponential", "MAX_ATTEMPTS": 5 },
      "impact": "The retry strategy affects all outgoing HTTP clients in the core module."
    }
  }
}]
</example_consolidation>

<example_completion>
Assistant: [Runs tests, they pass]
The tests passed. I'll clean up now.
[Uses prune with ids: ["20", "21"], metadata: { "reason": "completion" }]
</example_completion>

<example_keep>
Assistant: [Reads 'auth.ts' to understand the login flow]
I've understood the auth flow. I'll need to modify this file to add the new validation, so I'm keeping this read in context rather than distilling and pruning.
</example_keep>

<example_edit_completion>
Assistant: [Edits 'auth.ts' to add validation]
The edit was successful. I no longer need the raw edit content in context.
[Uses prune with ids: ["15"], metadata: { "reason": "completion" }]
</example_edit_completion>
